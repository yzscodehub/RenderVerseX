#include "Particle/Modules/LightsModule.h"
#include "Particle/ParticleTypes.h"
#include "Core/MathTypes.h"
#include <vector>
#include <algorithm>
#include <random>

namespace RVX::Particle
{

// ============================================================================
// Particle Light Data
// ============================================================================

/**
 * @brief Light instance generated by a particle
 */
struct ParticleLight
{
    Vec3 position;          ///< Light world position
    Vec4 color;             ///< Light color (RGB + intensity multiplier in A)
    float intensity;        ///< Light intensity
    float range;            ///< Light range/radius
    uint32 particleIndex;   ///< Source particle index
    bool active;            ///< Is this light active
};

// ============================================================================
// LightsModuleProcessor
// ============================================================================

/**
 * @brief Manages dynamic lights emitted by particles
 */
class LightsModuleProcessor
{
public:
    LightsModuleProcessor() = default;
    ~LightsModuleProcessor() = default;

    // =========================================================================
    // Initialization
    // =========================================================================

    void Initialize(uint32 maxLights)
    {
        m_maxLights = maxLights;
        m_lights.reserve(maxLights);
    }

    void Shutdown()
    {
        m_lights.clear();
    }

    // =========================================================================
    // Update
    // =========================================================================

    /**
     * @brief Update particle lights from current particle state
     * @param module Lights module configuration
     * @param particles Array of CPU particles
     * @param aliveIndices Indices of alive particles
     */
    void Update(
        const LightsModule& module,
        const std::vector<CPUParticle>& particles,
        const std::vector<uint32>& aliveIndices)
    {
        if (!module.enabled)
        {
            m_lights.clear();
            return;
        }

        // Determine which particles should emit lights
        std::vector<uint32> lightEmitters;
        lightEmitters.reserve(std::min(static_cast<size_t>(module.maxLights), aliveIndices.size()));

        if (module.randomDistribution)
        {
            // Randomly select particles based on ratio
            for (uint32 idx : aliveIndices)
            {
                if (lightEmitters.size() >= module.maxLights)
                    break;

                float roll = static_cast<float>(m_rng() % 10000) / 10000.0f;
                if (roll < module.ratio)
                {
                    lightEmitters.push_back(idx);
                }
            }
        }
        else
        {
            // Select first N particles based on ratio
            size_t count = static_cast<size_t>(aliveIndices.size() * module.ratio);
            count = std::min(count, static_cast<size_t>(module.maxLights));
            
            for (size_t i = 0; i < count && i < aliveIndices.size(); ++i)
            {
                lightEmitters.push_back(aliveIndices[i]);
            }
        }

        // Update or create lights
        m_lights.clear();
        m_lights.reserve(lightEmitters.size());

        for (uint32 idx : lightEmitters)
        {
            const CPUParticle& p = particles[idx];
            
            // Calculate normalized age
            float normalizedAge = p.lifetime > 0.0f ? p.age / p.lifetime : 1.0f;
            
            ParticleLight light;
            light.position = p.position;
            light.particleIndex = idx;
            light.active = true;
            
            // Apply intensity curve
            float intensityMod = module.intensityOverLifetime.Evaluate(normalizedAge);
            light.intensity = module.intensity * intensityMod;
            
            // Apply range curve
            float rangeMod = module.rangeOverLifetime.Evaluate(normalizedAge);
            light.range = module.range * rangeMod;
            
            // Apply color
            if (module.useParticleColor)
            {
                light.color = p.color;
            }
            else
            {
                light.color = module.lightColor;
            }
            
            // Modulate alpha with intensity
            light.color.w = light.intensity;
            
            m_lights.push_back(light);
        }
    }

    // =========================================================================
    // Render Data Export
    // =========================================================================

    /**
     * @brief Light data for GPU upload
     */
    struct GPULightData
    {
        Vec4 positionAndRange;  ///< xyz = position, w = range
        Vec4 colorAndIntensity; ///< xyz = color, w = intensity
    };

    /**
     * @brief Get GPU-ready light data
     * @return Vector of light data for shader upload
     */
    std::vector<GPULightData> GetGPULightData() const
    {
        std::vector<GPULightData> data;
        data.reserve(m_lights.size());

        for (const auto& light : m_lights)
        {
            if (!light.active)
                continue;

            GPULightData gpuLight;
            gpuLight.positionAndRange = Vec4(light.position, light.range);
            gpuLight.colorAndIntensity = Vec4(
                light.color.x, 
                light.color.y, 
                light.color.z, 
                light.intensity
            );
            data.push_back(gpuLight);
        }

        return data;
    }

    /**
     * @brief Get count of active lights
     */
    uint32 GetActiveLightCount() const
    {
        uint32 count = 0;
        for (const auto& light : m_lights)
        {
            if (light.active)
                count++;
        }
        return count;
    }

    // =========================================================================
    // Integration with Lighting System
    // =========================================================================

    /**
     * @brief Callback type for light registration
     */
    using LightRegistrationCallback = std::function<void(
        const Vec3& position,
        const Vec4& color,
        float intensity,
        float range,
        bool castShadows,
        bool affectsSpecular
    )>;

    /**
     * @brief Register particle lights with the lighting system
     * @param module Module configuration for shadow/specular settings
     * @param callback Callback to register each light
     */
    void RegisterWithLightingSystem(
        const LightsModule& module,
        LightRegistrationCallback callback)
    {
        for (const auto& light : m_lights)
        {
            if (!light.active)
                continue;

            callback(
                light.position,
                light.color,
                light.intensity,
                light.range,
                module.castShadows,
                module.affectsSpecular
            );
        }
    }

    // =========================================================================
    // Getters
    // =========================================================================

    const std::vector<ParticleLight>& GetLights() const { return m_lights; }

private:
    std::vector<ParticleLight> m_lights;
    uint32 m_maxLights = 10;
    std::minstd_rand m_rng{std::random_device{}()};
};

} // namespace RVX::Particle
